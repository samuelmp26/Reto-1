1. Ya había trabajado antes en un problema similar, así que tenía la idea clara de que lo mejor era separar cada operación 
(suma, resta, multiplicación y división) en funciones distintas dentro de una clase calculadora. Después solo necesitaba pedirle al
usuario dos números y dejar que eligiera la operación a realizar mediante un menú. Con esa base, la solución fue simplemente aplicar
cada función según la opción escogida y mostrar el resultado.

2. Pensé en que un palíndromo se reconoce comparando las letras desde el inicio y el final hacia el centro. Si en algún momento no
coinciden, deja de serlo. Por eso hice un ciclo que compara cada carácter con su opuesto y marqué la palabra como no palíndroma
si encontraba una diferencia.

3. Para resolver este ejercicio pensé primero en lo que define a un número primo: que no se puede dividir entre ningún número
aparte de 1 y de sí mismo. Con esa idea, decidí que la función debía probar la divisibilidad de cada número con los valores anteriores, 
así fui descartando los que tenían divisores y guardando los que no, formando al final la lista de números primos.

4. Pense que, para encontrar la mayor suma de dos números consecutivos, debía comparar cada par posible dentro de la lista. 
Por eso pensé en empezar con los dos primeros como referencia y luego ir avanzando posición por posición, actualizando
el valor más grande cuando encontraba una suma mayor. Así llegué a la idea de recorrer toda la lista y quedarme con el mayor.

5. Aquí pensé en qué hace que dos palabras sean “iguales” en cuanto a sus caracteres, incluso si están en distinto orden.
Me di cuenta de que si ordenaba alfabéticamente las letras de cada palabra, todas las que fueran anagramas se transformarían 
en el mismo string. Decidí agrupar las palabras según esa versión ordenada y luego devolver solo los gruposque tenían más de una palabra.
